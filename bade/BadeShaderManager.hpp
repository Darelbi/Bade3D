/*******************************************************************************
   Copyright (C) 2015 Dario Oliveri
   See copyright notice in LICENSE.md
*******************************************************************************/
#pragma once
#include "BadeForwards.hpp"
#include "BadeStdString.hpp"

namespace Bade {
	
	enum struct ShaderVersion: u8{
		gl3,		// #version 300
		gles2,
	};

	class BADE_API ShaderManager{

	public:
	
		/** Returns an object for creating shader options. */
		virtual ShaderOptionsPtr createOptions() = 0;
		
		/** Reuse a shader Options object. */
		virtual ShaderOptionsPtr shallowCopy( ShaderOptionsPtr & options) = 0;
		
		/** Utility usefull for learning and debugging.*/
		virtual StdString generateEmptyVertexShader( 
										ShaderOptionsPtr & options,
										ShaderVersion version) = 0;
										
		/** Utility usefull for learning and debugging.*/								
		virtual StdString generateEmptyFragmentShader(
										ShaderOptionsPtr & options,
										ShaderVersion version) = 0;
										
		/** Utility usefull for learning and debugging.*/
		virtual StdString generateEmptyGeometryShader( // no layers for now sorry ^^
										ShaderOptionsPtr & options,
										ShaderVersion version) = 0;
										
		/** Creates a VertexShader, note that for type safety reasons
			the boiler plate code of the shader is generated by the
			engine. You have only to provide the content of the "main"
			function. If you are in doubt, just see the output of
			"generateEmptyVertexShader".		
		*/
		virtual ShaderPtr createShader(	
								ShaderOptionsPtr & options,
								ShaderVersion version,
								VertexMain & vertexMain,
								FragmentMain & fragmentMain) = 0;
										
		/** Reuse same Shader, but allow different mesh data.*/		
		virtual ShaderPtr clone( ShaderPtr & shader)
	
		virtual ~ShaderManager(){}
	};
} // namespace Bade